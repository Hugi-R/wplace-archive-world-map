<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Wplace Daily Archives</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="canonical" href="https://wplace.eralyon.net/">
  <meta name="description" content="Daily archives of Wplace. Explore Wplace map starting from August 2025, and at any zoom level.">
  <meta name="keywords" content="wplace, archives, world map, zoom, back in time, download, overlay">
  <meta property="og:title" content="Wplace Daily Archives">
  <meta property="og:description" content="Daily archives of Wplace. Explore Wplace map starting from august 2025, and at any zoom level.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://wplace.eralyon.net/">
  <meta property="og:image" content="/preview.png">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Wplace Daily Archives">
  <meta name="twitter:description" content="Daily archives of Wplace. Explore Wplace map starting from august 2025, and at any zoom level.">
  <meta name="twitter:image" content="/preview.png">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link href="https://unpkg.com/maplibre-gl@5.7.1/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    :root {
      /* Primary UI colors */
      --button-face: #f5f5fa;
      --button-text: #222;
      --highlight: #cce4ff;
      --highlight-text: #222;
      --accent-color: #3399ff;
      --accent-color-text: #fff;

      /* Surfaces and panels */
      --panel-bg: rgba(255,255,255,0.95);
      --panel-bg-weak: rgba(255,255,255,0.8);
      --border-color: #e0e0e0;

      /* Shadows and outlines */
      --shadow-lg: 0 2px 8px rgba(0,0,0,0.10);
      --shadow-sm: 2px 2px 4px rgba(0,0,0,0.20);
      --shadow-mid: 0 2px 8px rgba(0,0,0,0.15);
      --outline-color: rgba(0,0,0,0.10);

      /* Context / menus */
      --context-bg: var(--panel-bg);
      --context-border: #ccc;
      --muted-text: #888;
      --muted-text-strong: #333;

      /* Tile overlay (canvas) colors */
      --tile-overlay-stroke: rgba(0,0,255,0.5);
      --tile-overlay-fill: rgba(0,0,255,1);
      --tile-overlay-id-outline: rgba(255,255,255,0.95);
      /* Page-level colors */
      --bg: #ffffff; /* page background */
      --text-color: #222222; /* default body text */

      /* Links */
      --link-color: #1a66cc;
      --link-visited: #5a4ea3;
      --link-hover: #0d4fa6;

      /* Form controls */
      --input-bg: #ffffff;
      --input-border: #dcdcdc;
      /* Focus / ring */
      --focus-ring: rgba(51,153,255,0.22);
    }
    body, html { 
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--text-color);
      accent-color: var(--accent-color);
      font-family: sans-serif;
    }
    input, select, textarea { background: var(--input-bg); border: 1px solid var(--input-border); color: var(--text-color); }
    a { color: var(--link-color); }
    a:visited { color: var(--link-visited); }
    a:hover { color: var(--link-hover); }

    /* Focus outlines and visible focus rings for keyboard users */
    :focus { outline: none; }
    :focus-visible, button:focus-visible, input:focus-visible, textarea:focus-visible, select:focus-visible, a:focus-visible {
      outline: 2px solid var(--accent-color);
      outline-offset: 2px;
      box-shadow: 0 0 0 4px var(--focus-ring);
    }
    /* Slightly different handling for small controls like checkboxes/radios */
    input[type="checkbox"]:focus-visible, input[type="radio"]:focus-visible {
      box-shadow: 0 0 0 4px var(--focus-ring);
      border-radius: 4px;
    }
    
    button {
      background: var(--button-face);
      color: var(--button-text);
      padding: 2px 4px;
      border-radius: 4px;
      font-size: 1rem;
      border: none;
      box-shadow: var(--shadow-sm);
      outline: 2px solid var(--outline-color);
      transition: background 0.2s, box-shadow 0.2s, outline 0.2s;
      cursor: pointer;
    }
    button:hover {
      background: var(--highlight);
      color: var(--highlight-text);
    }

    .zoom-button-container {
      display: flex;
      flex-direction: column;
      font-weight: bold;
      background: var(--button-face);
      padding: 3px;
      gap: 2px;
      border-radius: 7px;
      box-shadow: var(--shadow-sm);
      
      position: absolute; 
      bottom: 50px; 
      left: 10px; 
      z-index: 3;
    }

    button.toggled {
      background: var(--accent-color);
      color: var(--accent-color-text);
    }
    #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    #extra {
      position: absolute;
      top: 60px;
      left: 10px;
      z-index: 3;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: flex-start;
      pointer-events: auto;
    }
    #coord-input {
      background: var(--panel-bg-weak);
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 16px;
      /* Ensure it doesn't expand too much on narrow screens */
      max-width: calc(100vw - 40px);
    }
    @media (max-width: 600px) {
      #coord-input {
        display: none !important;
      }
    }
    #version-select {
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
      z-index: 100;
      background: var(--panel-bg);
      padding: 12px 12px;
      box-sizing: border-box;
      border-radius: 0;
      font-size: 17px;
      box-shadow: var(--shadow-lg);
      display: flex;
      align-items: center;
      gap: 16px;
      border-bottom: 1px solid var(--border-color);
    }
    #overlay-toggle {
      background: var(--panel-bg-weak);
      padding: 6px 12px;
      border-radius: 4px;
      font-size: 16px;
      z-index: 3;
      align-self: flex-start;
    }
    #encart {
      position: relative; /* allow #encart-close (absolute) to position relative to this box */
      z-index: 20;
      background: var(--panel-bg);
      border-radius: 4px;
      box-shadow: var(--shadow-lg);
      /* make room on the right for the close button */
      padding: 10px 24px 10px 16px;
      font-size: 16px;
      min-width: 220px;
      max-width: 320px;
      border: 1px solid var(--border-color);
      align-self: flex-start;
    }
    #encart-close {
      position: absolute;
      top: 6px;
      right: 10px;
      cursor: pointer;
      font-size: 18px;
      color: var(--muted-text);
      transition: color 0.2s;
      background: transparent;
      border: none;
      padding: 0;
      line-height: 1;
      appearance: none;
    }
    #encart-close:hover {
      color: var(--muted-text-strong);
    }
    #encart-content {
      margin-top: 2px;
      margin-right: 18px;
    }
    .version-slider {
      flex: 1;
      margin: 0;
    }
    @media (max-width: 500px) {
      #version-label {
        display: none !important;
      }
    }
    #context-menu {
      position: absolute; /* positioning is controlled from JS */
      display: none;
      z-index: 10;
      background: var(--context-bg);
      border: 1px solid var(--context-border);
      border-radius: 6px;
      box-shadow: var(--shadow-mid);
      padding: 8px 0;
      font-size: 15px;
      color: var(--button-text);
    }
    #context-menu > div { padding: 8px 24px; cursor: pointer; }
  </style>
</head>
<body>
  <main>
    <div id="map"></div>
  </main>
  <div id="version-select">
    <label id="version-label" for="wplace-version-slider">Version:</label>
    <input type="range" id="wplace-version-slider" min="0" max="0" value="0" step="1" class="version-slider" list="wplace-version-ticks">
    <span id="wplace-version-label" style="width: 14ch;"></span>
  </div>
  <div id="extra">
    <datalist id="wplace-version-ticks"></datalist>
    <div id="coord-input">
      <form id="goto-coord-form" style="display:flex;gap:6px;align-items:center;">
        <label for="coord-zoom" style="font-size:15px;">Zoom:</label>
        <input id="coord-zoom" type="number" step="any" style="width:60px;font-size:15px;" placeholder="Zoom" required>
        <label for="coord-lat" style="font-size:15px;">Lat:</label>
        <input id="coord-lat" type="number" step="any" style="width:80px;font-size:15px;" placeholder="Lat" required>
        <label for="coord-lng" style="font-size:15px;">Lng:</label>
        <input id="coord-lng" type="number" step="any" style="width:80px;font-size:15px;" placeholder="Lng" required>
        <button type="submit" style="font-size:15px;">Go</button>
      </form>
    </div>
    <div id="overlay-toggle">
      <label><input type="checkbox" id="toggle-tile-overlay"> Show tile overlay</label>
    </div>
    <div id="encart">
      <button id="encart-close" aria-label="Close encart" title="Close encart">&times;</button>
      <div id="encart-content">
        <p>Explore Wplace world map archives at any zoom level, starting from August 2025.</p>
        <p>Right-click the map for more tools</p>
        <p>Each zoom level halves the image resolution. The pixel is chosen by majority. Deleted pixels can linger up to a week.</p>
        <p>Data kindly provided by <a href="https://github.com/murolem/wplace-archives" target="_blank" rel="noopener noreferrer">murolem</a>, and previously <a href="https://www.reddit.com/user/OkInfluence36/" target="_blank" rel="noopener noreferrer">u/OkInfluence36</a>.</p>
        <p>This site is hosted on my own hardware and Cloudflare free tier, with enough storage to last one year of daily archives!</p>
        <p>Report bugs on <a href="https://github.com/Hugi-R/wplace-archive-world-map" target="_blank" rel="noopener noreferrer">GitHub</a> or to <a href="https://www.reddit.com/user/EralyonDotnet/" target="_blank" rel="noopener noreferrer">u/EralyonDotnet</a>.</p>
      </div>
    </div>
  </div>
    <div class="zoom-button-container">
      <button class="zoom-button" title="Zoom In" onclick="zoomIn()">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" width="22px" height="22px" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6">
          <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
        </svg>
      </button>
      <button class="zoom-button" title="Zoom Out" onclick="zoomOut()">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6">
          <path stroke-linecap="round" stroke-linejoin="round" d="M5 12h14" />
        </svg>
      </button>
    </div>
  <div id="transparency-toggle" style="position: absolute; bottom: 10px; left: 10px; z-index: 3;">
  <button id="toggle-transparency" title="Toggle art opacity" style="padding: 6px; font-size: 0px;">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960" width="22" height="22" fill="currentColor">
        <path d="M440-440v-80h80v80h-80Zm-80 80v-80h80v80h-80Zm160 0v-80h80v80h-80Zm80-80v-80h80v80h-80Zm-320 0v-80h80v80h-80Zm-80 320q-33 0-56.5-23.5T120-200v-560q0-33 23.5-56.5T200-840h560q33 0 56.5 23.5T840-760v560q0 33-23.5 56.5T760-120H200Zm80-80h80v-80h-80v80Zm160 0h80v-80h-80v80Zm320 0v-80 80Zm-560-80h80v-80h80v80h80v-80h80v80h80v-80h80v80h80v-80h-80v-80h80v-320H200v320h80v80h-80v80Zm0 80v-560 560Zm560-240v80-80ZM600-280v80h80v-80h-80Z"></path>
      </svg>
    </button>
  </div>

  <script src="https://unpkg.com/maplibre-gl@5.7.1/dist/maplibre-gl.js"></script>
  <script>
    // --- Encart close handler ---
    document.addEventListener('DOMContentLoaded', function() {
      var encartClose = document.getElementById('encart-close');
      var encart = document.getElementById('encart');
      if (encartClose && encart) {
        encartClose.onclick = function() {
          encart.style.display = 'none';
        };
      }
    });

    // --- Version slider setup ---
    // Injected from server: versions array [{version: 'v1', date: '2025-09-20'}, {version: 'v1.024', date: '2025-09-21'}, ...]
    const WPLACE_VERSIONS = [
      //$$VERSION_OPTIONS$$
    ];
    const versionSlider = document.getElementById('wplace-version-slider');
    const versionLabel = document.getElementById('wplace-version-label');
    const tickList = document.getElementById('wplace-version-ticks');
    versionSlider.max = WPLACE_VERSIONS.length - 1;
    versionSlider.value = WPLACE_VERSIONS.length - 1;
    // Add ticks and labels
    tickList.innerHTML = '';
    WPLACE_VERSIONS.forEach((v, i) => {
      const option = document.createElement('option');
      option.value = i;
      option.label = v.date;
      tickList.appendChild(option);
    });
    function updateVersionLabel(idx) {
      const v = WPLACE_VERSIONS[idx];
      versionLabel.textContent = v ? `${v.date}` : '';
    }
    // If a version is present in the URL, try to use it
    const _urlParams = new URLSearchParams(window.location.search);
    const _urlVersion = _urlParams.get('version');
    if (_urlVersion) {
      const _idx = WPLACE_VERSIONS.findIndex(v => v.version === _urlVersion);
      if (_idx >= 0) versionSlider.value = _idx;
    }
    updateVersionLabel(versionSlider.value);
    let wplaceVersion = WPLACE_VERSIONS[versionSlider.value].version;

    // Function to get wplace tile URL for selected version
    function getWplaceTileUrl(version) {
      return `merged://tiles/${version}/{z}/{x}/{y}.png`;
    }

    // Map style generator for a given wplace version
    function getMapStyle(version) {
      return {
        version: 8,
        sources: {
          osm: {
            type: 'raster',
            tiles: [
              'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png'
            ],
            minzoom: 0,
            maxzoom: 12,
            tileSize: 256,
            attribution: '© OpenStreetMap contributors'
          },
          wplace: {
            type: 'raster',
            tiles: [
              getWplaceTileUrl(version)
            ],
            minzoom: 0,
            maxzoom: 11,
            attribution: '© wplace.live'
          }
        },
        layers: [
          {
            id: 'osm',
            type: 'raster',
            source: 'osm',
            minzoom: 0,
            maxzoom: 19
          },
          {
            id: 'wplace',
            type: 'raster',
            source: 'wplace',
            minzoom: 0,
            maxzoom: 22,
            paint: {
              "raster-fade-duration": 0,
              "raster-resampling": "nearest"
            }
          }
        ]
      };
    }

    // Register custom protocol
    maplibregl.addProtocol('merged', async (params, abortControler) => {
      const { vBase, vDiff, z, x, y } = parseTileUrl(params.url);
      
      const cache = typeof caches !== 'undefined' ? await caches.open("merged-tiles") : null;
      const cacheKey = `tile-${vDiff ? vDiff : vBase}-${z}-${x}-${y}`;

      if (cache) {
        // Try to get from cache first
        const cachedResponse = await cache.match(cacheKey);
        if (cachedResponse) {
          const buffer = await cachedResponse.arrayBuffer();
          return {data: buffer};
        }
      }

      // No diff version, fetch only the base
      if (vDiff == null) {
        const [tile] = await Promise.all([
          fetch(`/tiles/${vBase}/${z}/${x}/${y}.png`)
        ]);
        if (tile.status == 200) {
          const buffer = await tile.arrayBuffer();

          if (cache) {
            // Store in cache
            const responseForCache = new Response(buffer, {
              headers: {
                'Content-Type': 'image/png',
                'Cache-Control': 'max-age=604800' // Cache for 7 days
              }
            });
            await cache.put(cacheKey, responseForCache);
          }

          return {data: buffer};
        }
        throw new Error(`Tile fetch error: ${tile.statusText}`);
      }

      // Else, fetch tiles from multiple sources
      const [tile1, tile2] = await Promise.all([
        fetch(`/tiles/${vBase}/${z}/${x}/${y}.png`),
        fetch(`/tiles/${vDiff}/${z}/${x}/${y}.png`)
      ]);

      if ((tile1.status != 200) && (tile2.status != 200)) {
        throw new Error("Both tile fetch error");
      }
      if ((tile1.status == 200) && (tile2.status != 200)) {
        // Return only the base
        const buffer = await tile1.arrayBuffer();
        return {data: buffer};
      }
      if ((tile1.status != 200) && (tile2.status == 200)) {
        // Return only the diff
        const buffer = await tile2.arrayBuffer();
        return {data: buffer};
      }
      const [blob1, blob2] = await Promise.all([
        tile1.blob(),
        tile2.blob()
      ]);
      
      // Merge tiles
      const merged = await mergeTileBlobs(blob1, blob2);
      const buffer = await merged.arrayBuffer();

      if (cache) {
        // Store in cache
        const responseForCache = new Response(buffer, {
          headers: {
            'Content-Type': 'image/png',
            'Cache-Control': 'max-age=604800' // Cache for 7 days
          }
        });
        await cache.put(cacheKey, responseForCache);
      }

      return {data: buffer};
    });

      // --- URL param helpers: read and update lat/lng/zoom ---
      function getInitialViewFromUrl() {
        const params = new URLSearchParams(window.location.search);
        const lat = parseFloat(params.get('lat'));
        const lng = parseFloat(params.get('lng'));
        const zoom = parseFloat(params.get('zoom'));
        const hasLatLng = !isNaN(lat) && !isNaN(lng);
        const hasZoom = !isNaN(zoom);
        const result = {
          center: [0, 0],
          zoom: 2
        };
        if (hasLatLng) {
          result.center = [lng, lat];
        }
        if (hasZoom) {
          result.zoom = zoom;
        }
        return result
      }

      function updateUrlWithMapView(mapInstance) {
        const center = mapInstance.getCenter();
        const zoom = mapInstance.getZoom();
        const params = new URLSearchParams(window.location.search);
        params.set('lat', center.lat.toFixed(6));
        params.set('lng', center.lng.toFixed(6));
        params.set('zoom', zoom.toFixed(2));
        if (typeof wplaceVersion !== 'undefined' && wplaceVersion) {
          params.set('version', wplaceVersion);
        }
        const newUrl = window.location.pathname + '?' + params.toString();
        history.replaceState(null, '', newUrl);
      }

    function parseTileUrl(url) {
      // Example: merged://tiles/version/z/x/y.png
      const match = url.match(/.*\/([^\/]+)\/(\d+)\/(\d+)\/(\d+)\.png/);
      if (!match) return {};
      const version = match[1]
      let vBase, vDiff;
      if (version.includes('.')) {
        vBase = version.split('.')[0];
        vDiff = version;
      } else {
        vBase = version;
        vDiff = null;
      }
      return {
      vBase: vBase,
      vDiff: vDiff,
      z: match[2],
      x: match[3],
      y: match[4]
      };
    }

    // Merge function - tile2 on top of tile1
    async function mergeTileBlobs(blob1, blob2, options = {}) {
      const {
        opacity = 1.0,        // Opacity of tile2 (0.0 to 1.0)
        blendMode = 'normal'  // Canvas composite operation
      } = options;
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // Load both images
      const img1 = await createImageBitmap(blob1);
      const img2 = await createImageBitmap(blob2);
      
      canvas.width = img1.width;
      canvas.height = img1.height;
      
      // Draw tile1 (base layer)
      ctx.drawImage(img1, 0, 0);
      
      // Draw tile2 on top
      ctx.globalAlpha = opacity;
      ctx.globalCompositeOperation = blendMode;
      ctx.drawImage(img2, 0, 0);
      
      // Convert to blob
      return new Promise(resolve => {
        canvas.toBlob(resolve, 'image/png');
      });
    }

    // Create map
    const _initialView = getInitialViewFromUrl();
    const map = new maplibregl.Map({
      container: 'map',
      style: getMapStyle(wplaceVersion),
      center: _initialView.center,
      zoom: _initialView.zoom
    });

    // Display and update zoom level
    const zoomDiv = document.getElementById('zoom-level');
    function updateZoom() {
      const zoomInput = document.getElementById('coord-zoom')
      if (zoomInput) {
        zoomInput.value = map.getZoom().toFixed(2);
      }
    }
    map.on('zoom', updateZoom);
    map.on('load', updateZoom);

    // Update URL when the map stops moving and keep inputs in sync
    map.on('moveend', function() {
      try {
        updateUrlWithMapView(map);
      } catch (e) {
        console.error(e);
      }
      // keep coordinate inputs up-to-date
      const latInput = document.getElementById('coord-lat');
      const lngInput = document.getElementById('coord-lng');
      if (latInput && lngInput) {
        const c = map.getCenter();
        latInput.value = c.lat.toFixed(6);
        lngInput.value = c.lng.toFixed(6);
      }
    });

    // Handle version slider change
    versionSlider.addEventListener('input', function(e) {
      const idx = parseInt(e.target.value);
      wplaceVersion = WPLACE_VERSIONS[idx].version;
      updateVersionLabel(idx);
      map.setStyle(getMapStyle(wplaceVersion));
      // after the style is applied, update zoom display and the url (so version is saved)
      map.once('styledata', function() { updateZoom(); try { updateUrlWithMapView(map); } catch (e) { console.error(e)} });
    });

    // --- Custom Right-Click Menu ---
    // Create menu element (colors & spacing handled by CSS variables/rules)
    const menu = document.createElement('div');
    menu.id = 'context-menu';
    menu.style.position = 'absolute';
    menu.style.display = 'none';
    menu.style.zIndex = '10';
    menu.innerHTML = `
      <div id="download-tile">Download tile</div>
      <div id="go-wplace-live">Go wplace.live</div>
    `;
    document.body.appendChild(menu);

    let lastTileCoords = null;
    let lastClickCoords = null;

    // Helper: get tile coordinates for a given lngLat and zoom
    function getTileCoords(lngLat, zoom) {
      const z = Math.floor(zoom);
      const x = Math.floor((lngLat.lng + 180) / 360 * Math.pow(2, z));
      const y = Math.floor((1 - Math.log(Math.tan(lngLat.lat * Math.PI / 180) + 1 / Math.cos(lngLat.lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, z));
      return { z, x, y };
    }

    // Show menu on right-click
    map.getContainer().addEventListener('contextmenu', function(e) {
      e.preventDefault();
      // Get map coordinates
      const rect = map.getContainer().getBoundingClientRect();
      const px = e.clientX - rect.left;
      const py = e.clientY - rect.top;
      const lngLat = map.unproject([px, py]);
      const zoom = Math.min(map.getZoom(), 11);
      lastTileCoords = getTileCoords(lngLat, zoom);
      lastClickCoords = { lat: lngLat.lat, lng: lngLat.lng, zoom: zoom };
      // Position menu
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';
      menu.style.display = 'block';
    });

    // Hide menu on click elsewhere
    document.addEventListener('click', function(e) {
      if (menu.style.display === 'block' && !menu.contains(e.target)) {
        menu.style.display = 'none';
      }
    });

    // Download tile handler
    document.getElementById('download-tile').addEventListener('click', async function() {
      if (!lastTileCoords) return;
      const { z, x, y } = lastTileCoords;
      
      if (typeof caches === 'undefined') {
        alert('Caching is not supported in this browser. Downloading tiles not available.');
        return;
      }

      // Get tile from cache
      const cache = await caches.open("merged-tiles");
      const cacheKey = `tile-${wplaceVersion}-${z}-${x}-${y}`;
      const cachedResponse = await cache.match(cacheKey);
      if (cachedResponse) {
        const blob = await cachedResponse.blob();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${wplaceVersion}-${z}-${x}-${y}.png`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        menu.style.display = 'none';    
      } else {
        alert('Tile not found in cache. Maybe the tile is empty?');
      }
    });

    document.getElementById('go-wplace-live').addEventListener('click', function() {
      if (!lastClickCoords) return;
      const { lat, lng, zoom } = lastClickCoords;
      const url = `https://wplace.live/?lat=${lat}&lng=${lng}&zoom=${zoom}`;
      window.open(url, '_blank');
      menu.style.display = 'none';
    });

    // --- Coordinate Input Handler ---
    document.getElementById('goto-coord-form').addEventListener('submit', function(e) {
      e.preventDefault();
      const zoom = parseFloat(document.getElementById('coord-zoom').value);
      const lat = parseFloat(document.getElementById('coord-lat').value);
      const lng = parseFloat(document.getElementById('coord-lng').value);
      if (isNaN(zoom) || isNaN(lat) || isNaN(lng)) return;
      map.flyTo({ center: [lng, lat], zoom: zoom });
    });

    const zoomIn = () => {
      const zoom = parseFloat(document.getElementById('coord-zoom').value) + parseFloat(1);
      const lat = parseFloat(document.getElementById('coord-lat').value);
      const lng = parseFloat(document.getElementById('coord-lng').value);
      if (isNaN(zoom) || isNaN(lat) || isNaN(lng)) return;
      map.flyTo({ center: [lng, lat], zoom: zoom });
    }

    const zoomOut = () => {
      const zoom = parseFloat(document.getElementById('coord-zoom').value - 1);
      const lat = parseFloat(document.getElementById('coord-lat').value);
      const lng = parseFloat(document.getElementById('coord-lng').value);
      if (isNaN(zoom) || isNaN(lat) || isNaN(lng)) return;
      map.flyTo({ center: [lng, lat], zoom: zoom });
    }

    // --- Canvas Overlay Setup ---
    let canvas, overlayToggle;
    map.on('load', function() {
      const mapContainer = document.getElementById('map');
      canvas = document.createElement('canvas');
      canvas.id = 'tile-overlay-canvas';
      canvas.style.position = 'absolute';
      canvas.style.top = '0';
      canvas.style.left = '0';
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.pointerEvents = 'none';
      canvas.style.zIndex = '5';
      mapContainer.appendChild(canvas);

      function resizeCanvas() {
        canvas.width = mapContainer.offsetWidth;
        canvas.height = mapContainer.offsetHeight;
      }
      window.addEventListener('resize', resizeCanvas);
      map.on('resize', resizeCanvas);
      resizeCanvas();

      // Prefill coordinate inputs from the current map center (initial load)
      const latInputInit = document.getElementById('coord-lat');
      const lngInputInit = document.getElementById('coord-lng');
      if (latInputInit && lngInputInit) {
        const c0 = map.getCenter();
        latInputInit.value = c0.lat.toFixed(6);
        lngInputInit.value = c0.lng.toFixed(6);
      }

      // Normalize/update URL once on initial load
      try { updateUrlWithMapView(map); } catch (e) { console.error(e); }

      // --- Overlay Toggle ---
      overlayToggle = document.getElementById('toggle-tile-overlay');
      function setOverlayVisibility() {
        canvas.style.display = overlayToggle.checked ? 'block' : 'none';
      }
      overlayToggle.addEventListener('change', setOverlayVisibility);
      setOverlayVisibility();

      // --- Draw Tile Overlay ---
      function lng2tileX(lng, z) {
        return Math.floor((lng + 180) / 360 * Math.pow(2, z));
      }
      function lat2tileY(lat, z) {
        const rad = lat * Math.PI / 180;
        return Math.floor((1 - Math.log(Math.tan(rad) + 1 / Math.cos(rad)) / Math.PI) / 2 * Math.pow(2, z));
      }
      function tile2lng(x, z) {
        return x / Math.pow(2, z) * 360 - 180;
      }
      function tile2lat(y, z) {
        const n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
        return 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
      }

      function drawTileOverlay() {
        if (!overlayToggle.checked) return;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const zoom = Math.min(Math.floor(map.getZoom()), 11);
        const bounds = map.getBounds();
        const tileCount = Math.pow(2, zoom);
        // Read canvas colors from CSS variables so they're centralized in :root
        const css = getComputedStyle(document.documentElement);
        const tileStroke = (css.getPropertyValue('--tile-overlay-stroke') || 'rgba(0,0,255,0.5)').trim();
        const tileFill = (css.getPropertyValue('--tile-overlay-fill') || 'rgba(0,0,255,1)').trim();
        const idOutline = (css.getPropertyValue('--tile-overlay-id-outline') || 'rgba(255,255,255,0.95)').trim();
        // Calculate visible tile range
        const minX = Math.max(0, lng2tileX(bounds.getWest(), zoom));
        const maxX = Math.min(tileCount - 1, lng2tileX(bounds.getEast(), zoom));
        const minY = Math.max(0, lat2tileY(bounds.getNorth(), zoom));
        const maxY = Math.min(tileCount - 1, lat2tileY(bounds.getSouth(), zoom));
        for (let x = minX; x <= maxX; x++) {
          for (let y = minY; y <= maxY; y++) {
            // Get tile bounds in lng/lat
            const west = tile2lng(x, zoom);
            const east = tile2lng(x + 1, zoom);
            const north = tile2lat(y, zoom);
            const south = tile2lat(y + 1, zoom);
            // Project to pixel
            const p1 = map.project([west, north]);
            const p2 = map.project([east, south]);
            // Draw rectangle
            ctx.strokeStyle = tileStroke;
            ctx.lineWidth = 3;
            ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
            // Draw ID
            ctx.font = 'bold 15px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const id = `${x},${y},${zoom}`;
            // Outline
            ctx.lineWidth = 3;
            ctx.lineJoin = 'round';
            ctx.strokeStyle = idOutline;
            ctx.strokeText(id, (p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
            // Fill
            ctx.fillStyle = tileFill;
            ctx.fillText(id, (p1.x + p2.x) / 2, (p1.y + p2.y) / 2);
          }
        }
      }

      // --- Redraw overlay on map events ---
      map.on('move', drawTileOverlay);
      map.on('zoom', drawTileOverlay);
      map.on('resize', drawTileOverlay);
      overlayToggle.addEventListener('change', drawTileOverlay);
      // Initial draw
      drawTileOverlay();
    });

    // --- Transparency Toggle ---
    document.addEventListener('DOMContentLoaded', function() {
      const transparencyButton = document.getElementById('toggle-transparency');
      let isTransparent = false;

      transparencyButton.addEventListener('click', function() {
        const wplaceLayer = map.getLayer('wplace');
        if (wplaceLayer) {
          isTransparent = !isTransparent;
          map.setPaintProperty('wplace', 'raster-opacity', isTransparent ? 0.3 : 1);
          transparencyButton.classList.toggle('toggled', isTransparent);
        }
      });
    });
  </script>
</body>
</html>
